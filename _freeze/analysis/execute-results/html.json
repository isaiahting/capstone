{
  "hash": "02e73d4c5194eb2b93f9de472e1f9a0e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Accessibility of Active Ageing Centre\"\ndate: \"July 1, 2025\"\ndate-modified: \"last-modified\"\nformat:\n html:\n    code-fold: false\n    code-summary: \"Code Chunk\"\n    number-sections: true\nexecute: \n  eval: false #r will run through all codes\n  echo: true #r will display all code chunk\n  warning: false #for markdown\n  freeze: true #r will not render all existing html files\n  message: false #avoid printing warning message\neditor: source\n---\n\n\n\n# Active Ageing Centre\n\n## Overview\n\nThis chapter covers pre-requisite preparation prior to the analysis alongside the analysis and its results.\n\n## Preparation\n\n### Installing Packages\n\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n| **Package**  | **Description**                                                                                                         |\n+==============+=========================================================================================================================+\n| sf           | For importing, managing, and handling geospatial data                                                                   |\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n| tidyverse    | For non-spatial data wrangling that includes dplyr, tibble, ggplot2, readr, tidyr, stringr, forcats, lubridate and purr |\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n| SpatialAcc   | For modelling spatial accessibility                                                                                     |\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n| tmap         | For creating elegent and cartographic quality thematic maps                                                             |\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n| ggstatsplot  | For statistical analysis and plotting                                                                                   |\n+--------------+-------------------------------------------------------------------------------------------------------------------------+\n\n: Table 1: *Files Preparation for QGIS*\n\nThe below code chunk installs and loads the abovementioned packages for this analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, SpatialAcc, reshape2, tmap, ggstatsplot)\n```\n:::\n\n\n\n### Importing Data\n\nThe file of the estimated population from 2025 to 2029 together with the hexagon layer is imported.\n\n+----------------+------------------------------------------------------------------------------------------------------------------+\n| **Name**       | **Details**                                                                                                      |\n+----------------+------------------------------------------------------------------------------------------------------------------+\n| `geriesti_hex` | -   Projected population of seniors above 60 years of age from Year 2025 to 2029                                 |\n|                |                                                                                                                  |\n|                | -   Hexagons ID                                                                                                  |\n|                |                                                                                                                  |\n|                | -   Geometies                                                                                                    |\n+----------------+------------------------------------------------------------------------------------------------------------------+\n| `cc_sf`        | -   Care Centres                                                                                                 |\n|                |                                                                                                                  |\n|                | -   Postal Codes of Care Centres                                                                                 |\n|                |                                                                                                                  |\n|                | -   Geometries of Care Centres                                                                                   |\n+----------------+------------------------------------------------------------------------------------------------------------------+\n| `mpsz`         | Singapore Master Plan 2019 Planning Subzone Boundary                                                             |\n+----------------+------------------------------------------------------------------------------------------------------------------+\n| `roadnetwork`  | [Road network of Singapore, Malaysia, Brunei](https://download.geofabrik.de/asia/malaysia-singapore-brunei.html) |\n|                |                                                                                                                  |\n|                | chosen over as data.giv has only road centre line                                                                |\n+----------------+------------------------------------------------------------------------------------------------------------------+\n\n: Table 2: *Files Preparation for QGIS*\n\n#### Estimated Senior Population with Hexagons Spatial Dataset\n\nFor the below code chunk, we will first read the spatial dataset, `geriesti_hex` and dropped the irrelevant columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeriesti_hex = read_rds(\"data/rds/mpsz/geriesti_hex_2025.rds\") %>%\n  select(-c('SUBZONE_N.x', 'SUBZONE_N.y', 'subzone_clean'))\n```\n:::\n\n\n\nFollowing, we use `st_write()` function from the package `sf` to save `geriesti_hex` to a file. it writes into \"data/qgis\" directory, creating a layer named \"geriesti_hex\", and saving it in the ESRI Shapefile format for QGIS later on.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(geriesti_hex, dsn = \"data/qgis\", layer = \"geriesti_hex\", driver = \"ESRI Shapefile\")\n```\n:::\n\n\n\n#### Active Ageing Centre (AAC) Spatial Dataset\n\nSimilar to the above code chunk, we will read the spatial dataset, `cc_sf` , then we will filter to AACs only. We will add a new column `capacity` where we will set the demand to 3000 seniors per AAC. Following which dropped the irrelevant columns in addition we use `unnest()` from the `tidyverse` package to convert the care centres column from list to column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naac_sf = read_rds(\"data/rds/carecentre/refined/cc_sf.rds\") %>%\n  filter(aac == 1) %>%\n  mutate(capacity = 3000) %>%\n  select(-c(postal_found, latitude_wgs84, longitude_wgs84)) %>%\n  unnest(3:11) #converts from list to column\n```\n:::\n\n\n\nThereafter, we will save `cc_sf` to a file for QGIS analysis.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(aac_sf, dsn = \"data/qgis\", layer = \"aac\", driver = \"ESRI Shapefile\")\n```\n:::\n\n\n\n#### Singapore Master Plan 2019 Planning Subzone Boundary\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz = st_read(dsn = \"data/planningarea/\",\n               layer = \"mpsz2019\")\n```\n:::\n\n\n\n### Road Network\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroadnetwork = st_read(dsn = \"data/roadnetwork/roadnetwork.shp/\",\n               layer = \"gis_osm_roads_free_1\")\n```\n:::\n\n\n\n### Data Preparation using QGIS\n\n#### Step 1: Adding `geriesti_hex` layer\n\nFirstly, locate the file to be be added as a layer. Then, drag and drop the file into the empty white space. The layer will appear as shown below.\n\n![Figure 1: *Adding `geriesti_hex` layer*](analysis_images/1.png)\n\n#### Step 2: Ensuring Correct CRS\n\nWe will right click on the `geriesti_hex` layer and click onto `Properties`.\n\n![Figure 2: Properties Panel](analysis_images/2.png)\n\nIn the below picture, we can see that the correct CRS (EPSG: 3414 - SVY21 / Singapore TM) is assigned.\n\n![Figure 3: Checking CRS](analysis_images/3.png)\n\n#### Step 3: Adding Road Network Layer\n\nSimilar to Step 1, we will drag and drop the `gis_osm_roads_free_1.shp` into the layer.\n\n![Figure 4: *Adding Road Network Layer*](analysis_images/4.png)\n\n#### Step 4: Adding Master Plan Subzone Boundary\n\nSimilar to Step 1, we will drag and drop the `mpsz2019.shp` into the layer.\n\n![Figure 5: *Adding `mpsz2019`* *Layer*](analysis_images/5.png)\n\n#### Step 5: Clipping Road Network\n\nAs the road network layer consists of the Singapore, Malaysia and Brunei, we would need to clip it to only Singapore's roads. We select `Vector -> Geoprocessing Tools -> Clip`.\n\n![Figure 6: *Clipping Function*](analysis_images/6.png)\n\nThe input layer will be `gis_osm_roads_free_1` while the overlay layer is `mpsz2019`. This ensures that the `gis_osm_roads_free_1` is trimmed according to the boundaries of Singapore, alias `mpsz2019`. We will click onto the tool button.\n\n![Figure 7: *Parameters of Clipping*](analysis_images/7.png)\n\nUnder invalid feature filtering, we will choose \"Do Not Filter'.\n\n![Figure 8: *Do Not Filter Parameter*](analysis_images/8.png)\n\nThe below is the output of the clipped road network named as `Clipped`.\n\n![Figure 9: *Output of Road Network*](analysis_images/9.png)\n\n#### Step 6: Exporting Road Network\n\nWe will right clicked onto the layer `Clipped`, select `Export -> Save Feature As...`.\n\n![Figure 10: *Exporting Road Network*](analysis_images/10.png)\n\nIn the format, we will select `GeoPackage`, selecting the appropriate location and naming the file.\n\n![Figure 11: *Saving Road Layer Layer*](analysis_images/11.png)\n\nFinal output of `roadnetwork` of Singapore is seen below.\n\n![Figure 12: *Final Output of Road Network of Singapore*](analysis_images/12.png)\n\nLastly, we will remove the `Clipped` layer as it is redundant. We will right clicked and select `Remove Layer`.\n\n![Figure 13: *Removing `Clipped` Layer*](analysis_images/13.png)\n\n#### Step 7: Adding AAC Layer\n\nFirst, Drag and drop the `cc.shp` into the map.\n\n![Figure 14: *Adding AAC Layer*](analysis_images/14.png)\n\n#### Step 8: Creating Centroids\n\nNext, we will select `Vector -> Geometry Tools -> Centroids` in creating the centroids of the AAC.\n\n![Figure 15: *Creating Centroids*](analysis_images/15.png)\n\nFor the parameters, ensure the layer with the hexagons is chosen, in this instance, `geriesti_hex`.\n\n![Figure 16: *Parameters of Creating Centroids*](analysis_images/16.png)\n\n#### Step 9: Exporting Centroids as Shapefile\n\nAfter running the previous step, you will be able to see the `Centroids`. Next, we will export the layer as a ShapeFile and save it.\n\n![Figure 17: *Exporting Centroids as Shape File*](analysis_images/17.png)\n\nIn this step, ensure that the file's format is set to ESRI Shapefile and the CRS is correct, then click onto OK to export. The file will be saved in the desired destination.\n\n![Figure 18: *Exporting Parameters*](analysis_images/18.png)\n\n## Computing Distance Matrix\n\nThis section will cover two different approaches in computing the distance matrix of centroids of the hexagons and AAC. The first approach uses the Manhanttan distance while the latter consists of using Euclidean Distance. The Manhatten distance utilises the road network of Singapore to compute while the Euclidean distance is a fly-by distance from the centroid to the AAC.\n\n### Manhattan Distance\n\nIn this subsection, the distance matrix was computed using QGIS. QGIS is much sophisticated in its computational abilities in relation to geospatial analysis as compared to using R Studio. The steps are laid in this section.\n\n#### Step 1: Selecting Distance Matrix\n\nUsing the same project from the above steps, click `Vector -> Analysis Tools -> Distance Matrix`.\n\n![Figure 19: *Selecting Distance Matrix*](analysis_images/19.png)\n\n#### Step 2: Selecting Parameters\n\nThe input point layer will be the `centroid_hex` while the input unique ID filed is the `hex_id`.\n\n![Figure 20: Selecting Parameters](analysis_images/20.png)\n\nThe target point layer will be the Active Ageing Centre (`cc`) and the unique ID field will be the `name`. We will then set the output matrix to be `Standard (N x T) Distance Matrix` and run it.\n\n![Figure 21: *Selecting Parameters Cont.*](analysis_images/21.png)\n\n#### Step 3: Checking Distance Matrix Table\n\nAfter running it, the new layer \"`Distance_matrix`\" will appear. Right click and `Open Attritube Table` in ensuring that there are no errors or missing values.\n\n![Figure 22: *Open Attribute Table*](analysis_images/22.png)\n\nThe attribute layer appears appropriate. The columns are the names of the Active Ageing Centres while the rows are the Hexagons IDs.\n\n![Figure 23: *Attribute Table*](analysis_images/23.png)\n\n#### Step 4: Exporting Distance Matrix\n\nAs we would like to the distance matrix table as a CSV file, we would need to right click the `Distance_matrix` layer and select `Export-> Save Features As...`.\n\n![Figure 24: *Exporting Distance Matrix*](analysis_images/24.png)\n\n#### Step 7: Saving as CSV File\n\nEnsure that the format is in Comma Separated Value (CSV) before selecting the directory to save.\n\n![Figure 25: *Exporting Parameters*](analysis_images/25.png)\n\n#### Step 8: Importing CSV\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naac_distmatrix_manhatten <- read.csv(\"data/qgis/distancematrix_aac.csv\")\n```\n:::\n\n\n\nThis code converts the distance matrix from meters to kilometers and rounds the values to 2 decimal places for better readability. It first removes the non-numeric ID column using `select(-ID)` because the previous division operation failed when trying to perform mathematical operations on mixed data types (the ID column contains character data while the distance columns contain numeric data). After removing the ID column, it converts the remaining data to a proper numeric matrix with `as.matrix()`, divides all values by 1000 to convert from meters to kilometers, and rounds the results to 2 decimal places.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naac_distmatrix_manhatten <- aac_distmatrix_manhatten %>%\n  select(-ID) %>%  # Remove the ID column\n  as.matrix() %>%  # Convert to matrix\n  `/`(1000) %>%    # Divide by 1000\n  round(2)         # Round to 2 decimal places\n```\n:::\n\n\n\n### Euclidean Distance\n\n#### Step 1: Creating Centroids in Hexagons\n\nThis code uses the `mutate` function to replace the original polygon geometry with point geometry representing the cent43 of each hexagon using the `st_centroid` function. Then, it selects only the `hex_id` column and the new centroid geometry, storing the result in a new object called `origin_centroids`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create centroids for the origin hexagons\norigin_centroids <- geriesti_hex %>%\n  mutate(\n    geometry = st_centroid(geometry)  # convert to centroids\n  ) %>%\n  select(hex_id, geometry)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n#### Step 2: Ensures Same Coordinate Reference System (CRS)\n\nThis code transforms the CRS of `origin_centroids` to match the CRS of `aac_sf`. It uses the `st_transform` function to reproject the centroid points and `st_crs` to extract the CRS from the `aac_sf` object, ensuring both datasets use the same spatial reference system for accurate spatial operations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 2: Ensure both datasets have the same CRS\norigin_centroids <- st_transform(origin_centroids, st_crs(aac_sf))\n```\n:::\n\n\n\n#### Step 3: Computing Distance Matrix\n\nThe below codechunk calculates the distances between every point in `origin_centroids` and every AAC in the `aac_sf` dataset, storing the results in a distance matrix called `distance_matrix`. The `st_distance` function computes the spatial distances between all combinations of features from the two datasets, creating a matrix where each row represents a centroid point and each column represents a feature from the `aac_sf` dataset.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_matrix <- st_distance(origin_centroids, aac_sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nview(distance_matrix)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n#### Step 4: Converting to Matrix\n\nThis code converts the distance matrix into a more usable format by first removing the measurement units with `as.numeric()`, then reshaping it into a proper matrix with rows equal to the number of origin centroids and columns equal to the number of features in the `aac_sf` dataset. It then assigns row names using the hexagon IDs from `origin_centroids` and column names using the names from the `aac_sf` dataset, creating an origin-destination matrix called `od_matrix` where you can easily look up distances between specific hexagons and destinations by name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod_matrix <- distance_matrix %>%\n  as.numeric() %>%  # Remove units\n  matrix(nrow = nrow(origin_centroids), ncol = nrow(aac_sf)) %>%\n  `rownames<-`(origin_centroids$hex_id) %>%\n  `colnames<-`(aac_sf$name)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\nThis code converts distance values from meters to kilometers and formats them to 2 decimal places. It starts by taking the existing `od_matrix` and dividing all values by 1000 to convert from meters to kilometers. The `as.matrix()` function ensures the result maintains the matrix format. Finally, the `round()` function with the parameter `2` rounds all the distance values to exactly 2 decimal places for cleaner presentation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod_km <- round(as.matrix(od_matrix/1000), 2)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### Grouping into Regions\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Modelling Accessibility using KD2SFCA Method\n\nThis calls the `ac()` function to calculate accessibility scores. The `geriesti_hex$aged_2025` provides the demand (elderly population in each hexagon), `aac_sf$capacity` provides the supply (how many people each care center can serve), and `od_km` is the distance matrix between all hexagons and care centers. The `d0 = 5` sets the maximum travel distance to 5 kilometers, `power = 2` means closer centers get exponentially more weight, and `family = \"KD2SFCA\"` specifies which accessibility method to use. The `data.frame()` wrapper converts the results into a data frame format.\n\n::: panel-tabset\n## 2025\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2025 <- data.frame(ac(geriesti_hex$aged_2025,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2025) <- \"acc_KD2SFCA_2025\"\nacc_KD2SFCA_2025  <- as_tibble(acc_KD2SFCA_2025)\nhex_KD2SFCA_2025 <- bind_cols(geriesti_hex, acc_KD2SFCA_2025)\n```\n:::\n\n\n\n## 2026\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2026 <- data.frame(ac(geriesti_hex$aged_2026,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2026) <- \"acc_KD2SFCA_2026\"\nacc_KD2SFCA_2026  <- as_tibble(acc_KD2SFCA_2026)\nhex_KD2SFCA_2026 <- bind_cols(geriesti_hex, acc_KD2SFCA_2026)\n```\n:::\n\n\n\n## 2027\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2027 <- data.frame(ac(geriesti_hex$aged_2027,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2027) <- \"acc_KD2SFCA_2027\"\nacc_KD2SFCA_2027  <- as_tibble(acc_KD2SFCA_2027)\nhex_KD2SFCA_2027 <- bind_cols(geriesti_hex, acc_KD2SFCA_2027)\n```\n:::\n\n\n\n## 2028\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2028 <- data.frame(ac(geriesti_hex$aged_2028,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2028) <- \"acc_KD2SFCA_2028\"\nacc_KD2SFCA_2028  <- as_tibble(acc_KD2SFCA_2028)\nhex_KD2SFCA_2028 <- bind_cols(geriesti_hex, acc_KD2SFCA_2028)\n```\n:::\n\n\n\n## 2029\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2029 <- data.frame(ac(geriesti_hex$aged_2029,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2029) <- \"acc_KD2SFCA_2029\"\nacc_KD2SFCA_2029  <- as_tibble(acc_KD2SFCA_2029)\nhex_KD2SFCA_2029 <- bind_cols(geriesti_hex, acc_KD2SFCA_2029)\n```\n:::\n\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2025\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2025, \"data/rds/analysis/aac/acc_KD2SFCA_2025.rds\")\nwrite_rds(hex_KD2SFCA_2025, \"data/rds/analysis/aac/hex_KD2SFCA_2025.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2026\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2026, \"data/rds/analysis/aac/acc_KD2SFCA_2026.rds\")\nwrite_rds(hex_KD2SFCA_2026, \"data/rds/analysis/aac/hex_KD2SFCA_2026.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2027\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2027, \"data/rds/analysis/aac/acc_KD2SFCA_2027.rds\")\nwrite_rds(hex_KD2SFCA_2027, \"data/rds/analysis/aac/hex_KD2SFCA_2027.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2028\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2028, \"data/rds/analysis/aac/acc_KD2SFCA_2028.rds\")\nwrite_rds(hex_KD2SFCA_2028, \"data/rds/analysis/aac/hex_KD2SFCA_2028.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2029\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2029, \"data/rds/analysis/aac/acc_KD2SFCA_2029.rds\")\nwrite_rds(hex_KD2SFCA_2029, \"data/rds/analysis/aac/hex_KD2SFCA_2029.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\nQuantiles\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(hex_KD2SFCA_2025$acc_KD2SFCA_2025, \n         probs = seq(0, 1, 0.1), \n         na.rm = TRUE)\n```\n:::\n\n\n\n## Modelling Accessibility using KD2SFCA Method (Manhanttan Distance)\n\nThis calls the `ac()` function to calculate accessibility scores. The `geriesti_hex$aged_2025` provides the demand (elderly population in each hexagon), `aac_sf$capacity` provides the supply (how many people each care center can serve), and `od_km` is the distance matrix between all hexagons and care centers. The `d0 = 5` sets the maximum travel distance to 5 kilometers, `power = 2` means closer centers get exponentially more weight, and `family = \"KD2SFCA\"` specifies which accessibility method to use. The `data.frame()` wrapper converts the results into a data frame format.\n\n::: panel-tabset\n## 2025\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2025_m <- data.frame(ac(geriesti_hex$aged_2025,\n                            aac_sf$capacity,\n                            aac_distmatrix_manhatten, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2025_m) <- \"acc_KD2SFCA_2025_m\"\nacc_KD2SFCA_2025_m  <- as_tibble(acc_KD2SFCA_2025_m)\nhex_KD2SFCA_2025_m <- bind_cols(geriesti_hex, acc_KD2SFCA_2025_m)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2025 <- data.frame(ac(geriesti_hex$aged_2025,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2025) <- \"acc_KD2SFCA_2025\"\nacc_KD2SFCA_2025  <- as_tibble(acc_KD2SFCA_2025)\nhex_KD2SFCA_2025 <- bind_cols(geriesti_hex, acc_KD2SFCA_2025)\n```\n:::\n\n\n\n## 2026\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2026 <- data.frame(ac(geriesti_hex$aged_2026,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2026) <- \"acc_KD2SFCA_2026\"\nacc_KD2SFCA_2026  <- as_tibble(acc_KD2SFCA_2026)\nhex_KD2SFCA_2026 <- bind_cols(geriesti_hex, acc_KD2SFCA_2026)\n```\n:::\n\n\n\n## 2027\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2027 <- data.frame(ac(geriesti_hex$aged_2027,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2027) <- \"acc_KD2SFCA_2027\"\nacc_KD2SFCA_2027  <- as_tibble(acc_KD2SFCA_2027)\nhex_KD2SFCA_2027 <- bind_cols(geriesti_hex, acc_KD2SFCA_2027)\n```\n:::\n\n\n\n## 2028\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2028 <- data.frame(ac(geriesti_hex$aged_2028,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2028) <- \"acc_KD2SFCA_2028\"\nacc_KD2SFCA_2028  <- as_tibble(acc_KD2SFCA_2028)\nhex_KD2SFCA_2028 <- bind_cols(geriesti_hex, acc_KD2SFCA_2028)\n```\n:::\n\n\n\n## 2029\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA_2029 <- data.frame(ac(geriesti_hex$aged_2029,\n                            aac_sf$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\ncolnames(acc_KD2SFCA_2029) <- \"acc_KD2SFCA_2029\"\nacc_KD2SFCA_2029  <- as_tibble(acc_KD2SFCA_2029)\nhex_KD2SFCA_2029 <- bind_cols(geriesti_hex, acc_KD2SFCA_2029)\n```\n:::\n\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2025\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2025, \"data/rds/analysis/aac/acc_KD2SFCA_2025.rds\")\nwrite_rds(hex_KD2SFCA_2025, \"data/rds/analysis/aac/hex_KD2SFCA_2025.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2026\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2026, \"data/rds/analysis/aac/acc_KD2SFCA_2026.rds\")\nwrite_rds(hex_KD2SFCA_2026, \"data/rds/analysis/aac/hex_KD2SFCA_2026.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2027\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2027, \"data/rds/analysis/aac/acc_KD2SFCA_2027.rds\")\nwrite_rds(hex_KD2SFCA_2027, \"data/rds/analysis/aac/hex_KD2SFCA_2027.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2028\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2028, \"data/rds/analysis/aac/acc_KD2SFCA_2028.rds\")\nwrite_rds(hex_KD2SFCA_2028, \"data/rds/analysis/aac/hex_KD2SFCA_2028.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 2029\n#| echo: false\n#| eval: false\nwrite_rds(acc_KD2SFCA_2029, \"data/rds/analysis/aac/acc_KD2SFCA_2029.rds\")\nwrite_rds(hex_KD2SFCA_2029, \"data/rds/analysis/aac/hex_KD2SFCA_2029.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Visualising Accessibility using 2SFCA Method\n\n### Extract Map Extend\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_ex <- st_bbox(geriesti_hex)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Adding into Region\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Method 1: Using left_join (recommended) with case insensitivity\nhex_KD2SFCA_2025 <- hex_KD2SFCA_2025 %>%\n  mutate(sz_upper = toupper(sz)) %>%  # Create uppercase version of sz\n  left_join(\n    mpsz %>% \n      st_drop_geometry() %>%  # Remove geometry to avoid conflicts\n      select(SUBZONE_N, REGION_N) %>%\n      mutate(SUBZONE_N_upper = toupper(SUBZONE_N)),  # Create uppercase version of SUBZONE_N\n    by = c(\"sz_upper\" = \"SUBZONE_N_upper\")\n  ) %>%\n  select(-sz_upper)  # Remove the temporary column\n```\n:::\n\n\n\n### 2025\n\nmanhatten distance\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#change to ro \ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2025_m,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2025_m\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2025\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\neuclidean\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2025,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2025\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2025\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\n### 2026\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2026,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2026\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2026\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\n### 2027\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2027,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2027\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2027\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\n### 2028\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2028,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2028\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2028\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\n### 2029\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(hex_KD2SFCA_2029,\n         bbox = map_ex) + \n  tm_fill(col = \"acc_KD2SFCA_2029\",\n          n = 10,\n          style = \"quantile\",\n          border.col = \"black\",\n          border.lwd = 1) +\ntm_shape(aac_sf) +\n  tm_symbols(size = 0.1) +\n  tm_layout(main.title = \"Accessibility to Active Ageing Centre in 2029\",\n            main.title.position = \"center\",\n            main.title.size = 0.5,\n            legend.outside = FALSE,\n            legend.height = 0.45, \n            legend.width = 3.0,\n            legend.format = list(digits = 6),\n            legend.position = c(\"right\", \"top\"),\n            frame = TRUE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.5)\n```\n:::\n\n\n\nStatistical Graphic Visualisation\n\n## 2025\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_KD2SFCA_2025 <- st_join(hex_KD2SFCA_2025, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hex_KD2SFCA_2025, \n       aes(y = log(acc_KD2SFCA_2025), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n:::\n\n\n\n## 2026\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_KD2SFCA_2026 <- st_join(hex_KD2SFCA_2026, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hex_KD2SFCA_2026, \n       aes(y = log(acc_KD2SFCA_2026), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n:::\n\n\n\n## 2027\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_KD2SFCA_2027 <- st_join(hex_KD2SFCA_2027, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hex_KD2SFCA_2027, \n       aes(y = log(acc_KD2SFCA_2027), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n:::\n\n\n\n## 2028\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_KD2SFCA_2028 <- st_join(hex_KD2SFCA_2028, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hex_KD2SFCA_2028, \n       aes(y = log(acc_KD2SFCA_2028), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n:::\n\n\n\n## 2029\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhex_KD2SFCA_2029 <- st_join(hex_KD2SFCA_2029, mpsz, \n                          join = st_intersects)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=hex_KD2SFCA_2029, \n       aes(y = log(acc_KD2SFCA_2029), \n           x= REGION_N)) +\n  geom_boxplot() +\n  geom_point(stat=\"summary\", \n             fun.y=\"mean\", \n             colour =\"red\", \n             size=2)\n```\n:::\n\n\n\n## Sensemaking\n\nEnquiries:\n\n1.  2SFCA + KD2SFCA (REVISED) - compartive and take base year such as 2025 only.\n    -   know the difference between them\n\n    -   2sfca: doesnt doesnt take into accounta distance fraction smoothly\n\n    -   \n2.  why od_km is in Nan B?\n3.  how to categorise in regions\n4.  populate both manhatten and eucldean distance? if yes, max dist change?\n\nrequest: 1. final report 2. poster samples\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}