{
  "hash": "13b1f5f3162390c66ea75e9e6fa5199c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Accessibility Analysis\"\ndate: \"July 1, 2025\"\ndate-modified: \"last-modified\"\nformat:\n html:\n    code-fold: false\n    code-summary: \"Code Chunk\"\n    number-sections: true\nexecute: \n  eval: false #r will run through all codes\n  echo: true #r will display all code chunk\n  warning: false #for markdown\n  freeze: true #r will not render all existing html files\n  message: false #avoid printing warning message\neditor: source\n---\n\n\n\n# Analysis\n\n## Preparation\n\n### Installing Packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse)\n```\n:::\n\n\n\n### Importing Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeriesti_hex_2025 = read_rds(\"data/rds/mpsz/geriesti_hex_2025.rds\")\ngeriesti_hex_2026 = read_rds(\"data/rds/mpsz/geriesti_hex_2026.rds\")\ngeriesti_hex_2027 = read_rds(\"data/rds/mpsz/geriesti_hex_2027.rds\")\ngeriesti_hex_2028 = read_rds(\"data/rds/mpsz/geriesti_hex_2028.rds\")\ngeriesti_hex_2029 = read_rds(\"data/rds/mpsz/geriesti_hex_2029.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncc_sf = read_rds(\"data/rds/carecentre/refined/cc_sf.rds\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\n# Calculating Distance Matrix\n\n## Origin is the centroid of the hexagon (hexagon id)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Create centroids for the origin hexagons\norigin_centroids <- geriesti_hex_2025 %>%\n  mutate(\n    geometry = st_centroid(geometry)  # convert to centroids\n  ) %>%\n  select(hex_id, geometry)\n```\n:::\n\n\n\n## Ensures Same CRS\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 2: Ensure both datasets have the same CRS\norigin_centroids <- st_transform(origin_centroids, st_crs(cc_sf))\n```\n:::\n\n\n\n## destination will be CC (postal code/name of centre)\n\n## Calculating Distance (Cost)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_matrix <- st_distance(origin_centroids, cc_sf)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Converting to Matrix\n\n\n\n::: {.cell}\n\n:::\n\n\n\nuse this\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod_matrix <- distance_matrix %>%\n  as.numeric() %>%  # Remove units\n  matrix(nrow = nrow(origin_centroids), ncol = nrow(cc_sf)) %>%\n  `rownames<-`(origin_centroids$hex_id) %>%\n  `colnames<-`(cc_sf$name)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\nThis code converts distance values from meters to kilometers and formats them to 2 decimal places. It starts by taking the existing `od_matrix` and dividing all values by 1000 to convert from meters to kilometers. The `as.matrix()` function ensures the result maintains the matrix format. Finally, the `round()` function with the parameter `2` rounds all the distance values to exactly 2 decimal places for cleaner presentation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod_km <- round(as.matrix(od_matrix/1000), 2)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Modelling and Visualising Accessibility using Hansen Method\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacc_KD2SFCA <- data.frame(ac(hexagons$demand,\n                            eldercare$capacity,\n                            od_km, \n                            d0 = 5, #max distance people willing to travel\n                            power = 2, #put higher weigh to nearer distance\n                            family = \"KD2SFCA\"))\n\ncolnames(acc_KD2SFCA) <- \"accKD2SFCA\"\nacc_KD2SFCA <- tbl_df(acc_KD2SFCA)\nhexagon_KD2SFCA <- bind_cols(hexagons, acc_KD2SFCA)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}